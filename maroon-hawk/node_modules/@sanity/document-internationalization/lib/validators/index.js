'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('config:@sanity/document-internationalization');
require('part:@sanity/base/schema');
var client = require('part:@sanity/base/client');
require('@babel/runtime/helpers/asyncToGenerator');
require('@babel/runtime/regenerator');
require('part:@sanity/document-internationalization/languages/loader?');
require('@babel/runtime/helpers/defineProperty');
require('lodash');
var types = require('@sanity/types');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var client__default = /*#__PURE__*/_interopDefaultLegacy(client);

var I18nPrefix = 'i18n';

var I18nDelimiter = '__i18n_';

var ReferenceBehavior;

(function (ReferenceBehavior) {
  ReferenceBehavior["STRONG"] = "strong";
  ReferenceBehavior["WEAK"] = "weak";
  ReferenceBehavior["DISABLED"] = "disabled";
})(ReferenceBehavior || (ReferenceBehavior = {}));

var IdStructure;

(function (IdStructure) {
  IdStructure["SUBPATH"] = "subpath";
  IdStructure["DELIMITER"] = "delimiter";
})(IdStructure || (IdStructure = {}));

var getSanityClient = function getSanityClient() {
  return client__default["default"].withConfig({
    apiVersion: "2021-10-01"
  });
};

var getBaseIdFromId = function getBaseIdFromId(id) {
  var nonDraftId = id.replace(/^drafts\./, ''); // subpath

  var rx = new RegExp("".concat(I18nPrefix, "\\.([^.]+)\\.[^.]+"));
  var match = nonDraftId.match(rx);
  if (match && match.length === 2) return match[1]; // delimiter

  var split = nonDraftId.split(I18nDelimiter);
  if (split.length > 0) return split[0];
  return nonDraftId;
};

function serializePath(path) {
  return path.reduce(function (target, part, i) {
    var isIndex = typeof part === 'number';
    var isKey = types.isKeyedObject(part);
    var separator = i === 0 ? '' : '.';
    var add = isIndex || isKey ? '[]' : "".concat(separator).concat(part);
    return "".concat(target).concat(add);
  }, '');
}

/**
 * @README most of this is taken from the deafultUnique function in @sanity/validation
 */

var isSlugUnique = function isSlugUnique(slug, context) {
  var document = context.document,
      path = context.path,
      type = context.type;
  var schemaOptions = type === null || type === void 0 ? void 0 : type.options;

  if (!document) {
    throw new Error("`document` was not provided in validation context.");
  }

  if (!path) {
    throw new Error("`path` was not provided in validation context.");
  }

  var disableArrayWarning = (schemaOptions === null || schemaOptions === void 0 ? void 0 : schemaOptions.disableArrayWarning) || false;
  var baseId = getBaseIdFromId(document._id);
  var docType = document._type;
  var atPath = serializePath(path.concat('current'));

  if (!disableArrayWarning && atPath.includes('[]')) {
    var serializedPath = serializePath(path);
    console.warn(["Slug field at path ".concat(serializedPath, " is within an array and cannot be automatically checked for uniqueness"), "If you need to check for uniqueness, provide your own \"isUnique\" method", "To disable this message, set `disableArrayWarning: true` on the slug `options` field"].join('\n'));
  }

  var constraints = ['_type == $docType', '!(_id in path("drafts.**"))', // exclude drafts
  '_id != $baseId', // exclude own base document
  '!(_id in path("i18n." + $baseId + ".*"))', // exclude any subpath translations
  "!(_id match $baseId  + \"".concat(I18nDelimiter, "*\")"), // exclude any delimiter based translations
  "".concat(atPath, " == $slug")].join(' && ');
  return getSanityClient().fetch("!defined(*[".concat(constraints, "][0]._id)"), {
    docType: docType,
    baseId: baseId,
    slug: slug
  }, {
    tag: 'validation.slug-is-unique'
  });
};

exports.isSlugUnique = isSlugUnique;
//# sourceMappingURL=index.js.map
